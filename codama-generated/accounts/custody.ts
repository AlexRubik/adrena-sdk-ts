/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  assertAccountExists,
  assertAccountsExist,
  combineCodec,
  decodeAccount,
  fetchEncodedAccount,
  fetchEncodedAccounts,
  fixDecoderSize,
  fixEncoderSize,
  getAddressDecoder,
  getAddressEncoder,
  getBytesDecoder,
  getBytesEncoder,
  getStructDecoder,
  getStructEncoder,
  getU8Decoder,
  getU8Encoder,
  transformEncoder,
  type Account,
  type Address,
  type Codec,
  type Decoder,
  type EncodedAccount,
  type Encoder,
  type FetchAccountConfig,
  type FetchAccountsConfig,
  type MaybeAccount,
  type MaybeEncodedAccount,
  type ReadonlyUint8Array,
} from '@solana/kit';
import {
  getAssetsDecoder,
  getAssetsEncoder,
  getBorrowRateParamsDecoder,
  getBorrowRateParamsEncoder,
  getBorrowRateStateDecoder,
  getBorrowRateStateEncoder,
  getFeesDecoder,
  getFeesEncoder,
  getFeesStatsDecoder,
  getFeesStatsEncoder,
  getPositionsAccountingDecoder,
  getPositionsAccountingEncoder,
  getPricingParamsDecoder,
  getPricingParamsEncoder,
  getTradeStatsDecoder,
  getTradeStatsEncoder,
  getVolumeStatsDecoder,
  getVolumeStatsEncoder,
  type Assets,
  type AssetsArgs,
  type BorrowRateParams,
  type BorrowRateParamsArgs,
  type BorrowRateState,
  type BorrowRateStateArgs,
  type Fees,
  type FeesArgs,
  type FeesStats,
  type FeesStatsArgs,
  type PositionsAccounting,
  type PositionsAccountingArgs,
  type PricingParams,
  type PricingParamsArgs,
  type TradeStats,
  type TradeStatsArgs,
  type VolumeStats,
  type VolumeStatsArgs,
} from '../types';

export const CUSTODY_DISCRIMINATOR = new Uint8Array([
  1, 184, 48, 81, 93, 131, 63, 145,
]);

export function getCustodyDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(CUSTODY_DISCRIMINATOR);
}

export type Custody = {
  discriminator: ReadonlyUint8Array;
  bump: number;
  tokenAccountBump: number;
  allowTrade: number;
  allowSwap: number;
  decimals: number;
  isStable: number;
  padding: ReadonlyUint8Array;
  pool: Address;
  mint: Address;
  tokenAccount: Address;
  oracle: Address;
  tradeOracle: Address;
  pricing: PricingParams;
  fees: Fees;
  borrowRate: BorrowRateParams;
  collectedFees: FeesStats;
  volumeStats: VolumeStats;
  tradeStats: TradeStats;
  assets: Assets;
  longPositions: PositionsAccounting;
  shortPositions: PositionsAccounting;
  borrowRateState: BorrowRateState;
};

export type CustodyArgs = {
  bump: number;
  tokenAccountBump: number;
  allowTrade: number;
  allowSwap: number;
  decimals: number;
  isStable: number;
  padding: ReadonlyUint8Array;
  pool: Address;
  mint: Address;
  tokenAccount: Address;
  oracle: Address;
  tradeOracle: Address;
  pricing: PricingParamsArgs;
  fees: FeesArgs;
  borrowRate: BorrowRateParamsArgs;
  collectedFees: FeesStatsArgs;
  volumeStats: VolumeStatsArgs;
  tradeStats: TradeStatsArgs;
  assets: AssetsArgs;
  longPositions: PositionsAccountingArgs;
  shortPositions: PositionsAccountingArgs;
  borrowRateState: BorrowRateStateArgs;
};

export function getCustodyEncoder(): Encoder<CustodyArgs> {
  return transformEncoder(
    getStructEncoder([
      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
      ['bump', getU8Encoder()],
      ['tokenAccountBump', getU8Encoder()],
      ['allowTrade', getU8Encoder()],
      ['allowSwap', getU8Encoder()],
      ['decimals', getU8Encoder()],
      ['isStable', getU8Encoder()],
      ['padding', fixEncoderSize(getBytesEncoder(), 2)],
      ['pool', getAddressEncoder()],
      ['mint', getAddressEncoder()],
      ['tokenAccount', getAddressEncoder()],
      ['oracle', getAddressEncoder()],
      ['tradeOracle', getAddressEncoder()],
      ['pricing', getPricingParamsEncoder()],
      ['fees', getFeesEncoder()],
      ['borrowRate', getBorrowRateParamsEncoder()],
      ['collectedFees', getFeesStatsEncoder()],
      ['volumeStats', getVolumeStatsEncoder()],
      ['tradeStats', getTradeStatsEncoder()],
      ['assets', getAssetsEncoder()],
      ['longPositions', getPositionsAccountingEncoder()],
      ['shortPositions', getPositionsAccountingEncoder()],
      ['borrowRateState', getBorrowRateStateEncoder()],
    ]),
    (value) => ({ ...value, discriminator: CUSTODY_DISCRIMINATOR })
  );
}

export function getCustodyDecoder(): Decoder<Custody> {
  return getStructDecoder([
    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
    ['bump', getU8Decoder()],
    ['tokenAccountBump', getU8Decoder()],
    ['allowTrade', getU8Decoder()],
    ['allowSwap', getU8Decoder()],
    ['decimals', getU8Decoder()],
    ['isStable', getU8Decoder()],
    ['padding', fixDecoderSize(getBytesDecoder(), 2)],
    ['pool', getAddressDecoder()],
    ['mint', getAddressDecoder()],
    ['tokenAccount', getAddressDecoder()],
    ['oracle', getAddressDecoder()],
    ['tradeOracle', getAddressDecoder()],
    ['pricing', getPricingParamsDecoder()],
    ['fees', getFeesDecoder()],
    ['borrowRate', getBorrowRateParamsDecoder()],
    ['collectedFees', getFeesStatsDecoder()],
    ['volumeStats', getVolumeStatsDecoder()],
    ['tradeStats', getTradeStatsDecoder()],
    ['assets', getAssetsDecoder()],
    ['longPositions', getPositionsAccountingDecoder()],
    ['shortPositions', getPositionsAccountingDecoder()],
    ['borrowRateState', getBorrowRateStateDecoder()],
  ]);
}

export function getCustodyCodec(): Codec<CustodyArgs, Custody> {
  return combineCodec(getCustodyEncoder(), getCustodyDecoder());
}

export function decodeCustody<TAddress extends string = string>(
  encodedAccount: EncodedAccount<TAddress>
): Account<Custody, TAddress>;
export function decodeCustody<TAddress extends string = string>(
  encodedAccount: MaybeEncodedAccount<TAddress>
): MaybeAccount<Custody, TAddress>;
export function decodeCustody<TAddress extends string = string>(
  encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>
): Account<Custody, TAddress> | MaybeAccount<Custody, TAddress> {
  return decodeAccount(
    encodedAccount as MaybeEncodedAccount<TAddress>,
    getCustodyDecoder()
  );
}

export async function fetchCustody<TAddress extends string = string>(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  address: Address<TAddress>,
  config?: FetchAccountConfig
): Promise<Account<Custody, TAddress>> {
  const maybeAccount = await fetchMaybeCustody(rpc, address, config);
  assertAccountExists(maybeAccount);
  return maybeAccount;
}

export async function fetchMaybeCustody<TAddress extends string = string>(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  address: Address<TAddress>,
  config?: FetchAccountConfig
): Promise<MaybeAccount<Custody, TAddress>> {
  const maybeAccount = await fetchEncodedAccount(rpc, address, config);
  return decodeCustody(maybeAccount);
}

export async function fetchAllCustody(
  rpc: Parameters<typeof fetchEncodedAccounts>[0],
  addresses: Array<Address>,
  config?: FetchAccountsConfig
): Promise<Account<Custody>[]> {
  const maybeAccounts = await fetchAllMaybeCustody(rpc, addresses, config);
  assertAccountsExist(maybeAccounts);
  return maybeAccounts;
}

export async function fetchAllMaybeCustody(
  rpc: Parameters<typeof fetchEncodedAccounts>[0],
  addresses: Array<Address>,
  config?: FetchAccountsConfig
): Promise<MaybeAccount<Custody>[]> {
  const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);
  return maybeAccounts.map((maybeAccount) => decodeCustody(maybeAccount));
}

export function getCustodySize(): number {
  return 824;
}
